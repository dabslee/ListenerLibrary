{% extends "base.html" %}
{% load player_extras %}

{% block content %}
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2>{{ playlist.name }}</h2>
        <div class="d-flex flex-wrap justify-content-end gap-1">
            <button id="play-all-btn" class="btn btn-success"><i class="fas fa-play me-2"></i>Play All</button>
            <a href="{% url 'edit_playlist' playlist.id %}" class="btn btn-primary"><i class="fas fa-pen me-2"></i>Edit Playlist Details</a>
        </div>
    </div>

    <div class="card bg-light mb-4">
        <div class="card-body">
            <form id="filter-sort-form" onsubmit="return false;">
                <div class="row g-3 align-items-end">
                    <div class="col-md-6">
                        <label for="title-search-input" class="form-label">Title Search</label>
                        <input type="text" id="title-search-input" class="form-control" value="{{ search_title_query|default:'' }}" placeholder="Keyword...">
                    </div>
                    <div class="col-md-6 position-relative">
                        <label for="transcript-search-input" class="form-label">Transcript Search</label>
                        <input type="text" id="transcript-search-input" class="form-control" value="{{ transcript_search_query|default:'' }}" placeholder="Transcript text..." autocomplete="off">
                        <div id="transcript-results-dropdown" class="dropdown-menu w-100 shadow" style="display: none; max-height: 300px; overflow-y: auto;">
                            <!-- Results will be injected here -->
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <div class="row">
        <div class="col-md-4">
            {% if playlist.image %}
                <img src="{{ playlist.image.url }}" alt="{{ playlist.name }}" class="img-fluid rounded mb-3">
            {% else %}
                <div class="bg-secondary d-flex align-items-center justify-content-center rounded mb-3" style="width: 100%; height: 300px;">
                    <i class="fas fa-music fa-3x text-white"></i>
                </div>
            {% endif %}
        </div>
        <div class="col-md-8">
            <h3>Tracks</h3>
            <ul id="playlist-tracks" class="list-group">
                {% include 'player/partials/playlist_item_list.html' with playlist=playlist playlist_items=playlist_items %}
            </ul>
        </div>
    </div>

    <!-- Remove Track Modal -->
    <div class="modal fade" id="removeTrackModal" tabindex="-1" aria-labelledby="removeTrackModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="removeTrackModalLabel">Confirm Removal</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    Are you sure you want to remove the track "<strong id="track-name-to-remove"></strong>" from this playlist?
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-remove-btn">Remove</button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block extra_js %}
<script>
let playlistData = [
    {% for item in playlist_items %}
    {
        id: {{ item.track.id }},
        name: "{{ item.track.name|escapejs }}",
        artist: "{{ item.track.artist|escapejs }}",
        stream_url: "{% url 'stream_track' item.track.id %}",
        icon_url: {% if item.track.icon %}"{{ item.track.icon.url }}"{% else %}null{% endif %},
        type: "{{ item.track.type }}",
        position: {{ item.track.position|default:0 }},
        duration: {{ item.track.duration|default:0 }}
    },
    {% endfor %}
];

</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const titleSearchInput = document.getElementById('title-search-input');
    const transcriptSearchInput = document.getElementById('transcript-search-input');
    const playlistTracks = document.getElementById('playlist-tracks');
    const transcriptResultsDropdown = document.getElementById('transcript-results-dropdown');

    let sortableInstance = null;

    function initSortable() {
        if (playlistTracks && !sortableInstance) {
            sortableInstance = new Sortable(playlistTracks, {
                animation: 150,
                handle: '.fa-grip-vertical',
                onEnd: function (evt) {
                    const trackIds = Array.from(evt.target.children).map(li => li.dataset.trackId);
                    const reorderUrl = "{% url 'reorder_playlist' playlist.id %}";

                    const formData = new FormData();
                    trackIds.forEach(id => formData.append('track_ids[]', id));

                    fetch(reorderUrl, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': '{{ csrf_token }}',
                        },
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status !== 'success') {
                            console.error('Failed to reorder playlist');
                        } else {
                            // Re-sync the playlistData array with the new order
                            const reorderedPlaylistData = [];
                            trackIds.forEach(id => {
                                const track = playlistData.find(t => t.id == id);
                                if(track) reorderedPlaylistData.push(track);
                            });
                            playlistData = reorderedPlaylistData;
                        }
                    })
                    .catch(error => console.error('Error:', error));
                }
            });
        }
    }

    function destroySortable() {
        if (sortableInstance) {
            sortableInstance.destroy();
            sortableInstance = null;
        }
    }

    initSortable();

    let transcriptSearchTimeout = null;

    function highlightText(text, query) {
        if (!query) return text;
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<mark class="p-0" style="background-color: yellow;">$1</mark>');
    }

    function handleTranscriptSearch() {
        const query = transcriptSearchInput.value;
        if (query.length < 2) {
            transcriptResultsDropdown.style.display = 'none';
            return;
        }

        clearTimeout(transcriptSearchTimeout);
        transcriptSearchTimeout = setTimeout(() => {
            fetch(`/api/search_transcripts/?q=${encodeURIComponent(query)}&playlist_id={{ playlist.id }}`)
                .then(response => response.json())
                .then(data => {
                    if (data.length > 0) {
                        transcriptResultsDropdown.innerHTML = '';
                        data.forEach(result => {
                            const item = document.createElement('a');
                            item.className = 'dropdown-item d-flex align-items-center gap-2 py-2';
                            item.href = '#';
                            item.style.whiteSpace = 'normal';
                            const highlightedText = highlightText(result.text, query);
                            item.innerHTML = `
                                <div class="flex-shrink-0">
                                    ${result.track_icon ? `<img src="${result.track_icon}" style="width: 32px; height: 32px; object-fit: cover; border-radius: 4px;">` : `<div class="bg-secondary d-flex align-items-center justify-content-center" style="width: 32px; height: 32px; border-radius: 4px;"><i class="fas fa-music text-white small"></i></div>`}
                                </div>
                                <div class="flex-grow-1 min-width-0">
                                    <div class="d-flex justify-content-between align-items-baseline">
                                        <strong class="text-truncate" style="max-width: 150px;">${result.track_name}</strong>
                                        <small class="text-primary ms-2">${result.start_time_formatted}</small>
                                    </div>
                                    <div class="small text-muted" style="word-wrap: break-word;">${highlightedText}</div>
                                </div>
                            `;
                            item.addEventListener('click', (e) => {
                                e.preventDefault();
                                // We want to play from the playlist context if possible
                                // Find if the track is in the current (filtered) playlist data
                                const trackInPlaylist = playlistData.find(t => t.id === result.track_id);
                                if (trackInPlaylist) {
                                    // Update its position temporarily for playPlaylist to use it
                                    const originalPosition = trackInPlaylist.position;
                                    trackInPlaylist.position = result.start_time;
                                    const index = playlistData.indexOf(trackInPlaylist);
                                    window.playPlaylist({{ playlist.id }}, "{{ playlist.name|escapejs }}", playlistData, index);
                                    // Restore position if needed (though it will be updated by playback soon)
                                } else {
                                    // Fallback to playTrack if for some reason not in playlistData (shouldn't happen here)
                                    window.playTrack(
                                        result.track_stream_url,
                                        result.track_name,
                                        result.track_artist,
                                        result.track_icon,
                                        result.track_id,
                                        result.track_type,
                                        result.start_time,
                                        result.track_duration
                                    );
                                }
                                transcriptResultsDropdown.style.display = 'none';
                            });
                            transcriptResultsDropdown.appendChild(item);
                        });
                    } else {
                        const noResults = document.createElement('div');
                        noResults.className = 'dropdown-item text-muted py-2';
                        noResults.textContent = 'No results found';
                        transcriptResultsDropdown.appendChild(noResults);
                    }
                    transcriptResultsDropdown.style.display = 'block';
                });
        }, 300);
    }

    transcriptSearchInput.addEventListener('input', handleTranscriptSearch);

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!transcriptSearchInput.contains(e.target) && !transcriptResultsDropdown.contains(e.target)) {
            transcriptResultsDropdown.style.display = 'none';
        }
    });

    function fetchFilteredTracks() {
        const searchTitle = titleSearchInput.value;

        if (searchTitle) {
            destroySortable();
        } else {
            initSortable();
        }

        const params = new URLSearchParams({
            search_title: searchTitle
        });
        const url = `?${params.toString()}`;

        fetch(url, {
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            playlistTracks.innerHTML = data.html;
            playlistData = data.playlist_data;
            initTooltips();
        })
        .catch(error => console.error('Error fetching filtered tracks:', error));
    }

    titleSearchInput.addEventListener('input', fetchFilteredTracks);

    function initTooltips() {
        const tooltipElements = document.querySelectorAll('[data-bs-toggle="tooltip"]');
        tooltipElements.forEach(el => {
            const existing = bootstrap.Tooltip.getInstance(el);
            if (existing) {
                existing.dispose();
            }
            new bootstrap.Tooltip(el);
        });
    }
    initTooltips();

    let playlistIdToRemove = null;
    let trackIdToRemove = null;

    const removeTrackModal = document.getElementById('removeTrackModal');
    if (removeTrackModal) {
        removeTrackModal.addEventListener('show.bs.modal', function (event) {
            const button = event.relatedTarget;
            playlistIdToRemove = button.dataset.playlistId;
            trackIdToRemove = button.dataset.trackId;
            const trackName = button.dataset.trackName;
            const trackNameElement = document.getElementById('track-name-to-remove');
            trackNameElement.textContent = trackName;
        });
    }

    const confirmRemoveBtn = document.getElementById('confirm-remove-btn');
    if (confirmRemoveBtn) {
        confirmRemoveBtn.addEventListener('click', function () {
            if (!playlistIdToRemove || !trackIdToRemove) return;

            const url = `/playlists/remove_track/${playlistIdToRemove}/${trackIdToRemove}/`;
            const csrfToken = '{{ csrf_token }}';

            fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const itemToRemove = document.getElementById(`playlist-item-${trackIdToRemove}`);
                    if (itemToRemove) {
                        itemToRemove.remove();
                    }
                    playlistData = playlistData.filter(track => track.id !== parseInt(trackIdToRemove));
                    showToast(data.message, 'success');
                    const modalInstance = bootstrap.Modal.getInstance(removeTrackModal);
                    modalInstance.hide();
                } else {
                    showToast('Error: ' + data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showToast('An error occurred while removing the track.', 'error');
            });
        });
    }
    const playAllBtn = document.getElementById('play-all-btn');
    if (playAllBtn) {
        playAllBtn.addEventListener('click', function(e) {
            e.preventDefault();
            if (playlistData.length > 0) {
                window.playPlaylist({{ playlist.id }}, "{{ playlist.name|escapejs }}", playlistData, 0);
            } else {
                showToast("This playlist is empty!", "warning");
            }
        });
    }
});
</script>
{% endblock %}
