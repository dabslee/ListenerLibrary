{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <h2>Transcripts Dashboard</h2>
    <div class="table-responsive">
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Track</th>
                    <th>Status</th>
                    <th>Created</th>
                    <th>Processing Started</th>
                    <th>Updated</th>
                    <th class="text-end">Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for transcript in transcripts %}
                <tr data-transcript-id="{{ transcript.id }}" data-track-id="{{ transcript.track.id }}">
                    <td>{{ transcript.track.name }}</td>
                    <td class="status-cell">
                        {% include "player/partials/transcript_status.html" %}
                    </td>
                    <td><span class="local-datetime" data-local-datetime="{{ transcript.created_at|date:'c' }}">{{ transcript.created_at|date:"M d, Y H:i" }}</span></td>
                    <td><span class="local-datetime" data-local-datetime="{{ transcript.processing_started_at|date:'c' }}">{{ transcript.processing_started_at|date:"M d, Y H:i" }}</span></td>
                    <td><span class="local-datetime" data-local-datetime="{{ transcript.updated_at|date:'c' }}">{{ transcript.updated_at|date:"M d, Y H:i" }}</span></td>
                    <td class="text-end actions-cell">
                        {% include "player/partials/transcript_actions.html" with show_edit_track=True %}
                    </td>
                </tr>
                {% empty %}
                <tr>
                    <td colspan="6" class="text-center">No transcripts found.</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% if transcripts.paginator.num_pages > 1 %}
            <nav aria-label="Transcript pagination" id="pagination-container">
                <ul class="pagination justify-content-center">
                    {% if transcripts.has_previous %}
                        <li class="page-item"><a class="page-link" href="?page=1">&laquo; First</a></li>
                        <li class="page-item"><a class="page-link" href="?page={{ transcripts.previous_page_number }}">Previous</a></li>
                    {% else %}
                        <li class="page-item disabled"><a class="page-link" href="#">&laquo; First</a></li>
                        <li class="page-item disabled"><a class="page-link" href="#">Previous</a></li>
                    {% endif %}

                    {% for i in transcripts.paginator.page_range %}
                        {% if transcripts.number == i %}
                            <li class="page-item active" aria-current="page"><span class="page-link">{{ i }}</span></li>
                        {% else %}
                            <li class="page-item"><a class="page-link" href="?page={{ i }}">{{ i }}</a></li>
                        {% endif %}
                    {% endfor %}

                    {% if transcripts.has_next %}
                        <li class="page-item"><a class="page-link" href="?page={{ transcripts.next_page_number }}">Next</a></li>
                        <li class="page-item"><a class="page-link" href="?page={{ transcripts.paginator.num_pages }}">Last &raquo;</a></li>
                    {% else %}
                        <li class="page-item disabled"><a class="page-link" href="#">Next</a></li>
                        <li class="page-item disabled"><a class="page-link" href="#">Last &raquo;</a></li>
                    {% endif %}
                </ul>
            </nav>
        {% endif %}
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const pollInterval = 5000; // 5 seconds
    const csrfToken = '{{ csrf_token }}';

    function checkStatus() {
        const processingRows = document.querySelectorAll('tr[data-transcript-id]');
        const idsToCheck = [];

        processingRows.forEach(row => {
            const badge = row.querySelector('.badge');
            if (badge && (badge.textContent.trim().toLowerCase() === 'processing' || badge.textContent.trim().toLowerCase() === 'pending')) {
                idsToCheck.push(row.dataset.trackId);
            }
        });

        if (idsToCheck.length === 0) return;

        idsToCheck.forEach(trackId => {
            fetch(`/api/transcript/status/${trackId}/?show_edit_track=true`)
                .then(response => response.json())
                .then(data => {
                    if (data.html) {
                        const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                        if (row) {
                            const statusCell = row.querySelector('.status-cell');
                            // Only update if status changed or content is different
                            if (statusCell.innerHTML.trim() !== data.html.trim()) {
                                statusCell.innerHTML = data.html;
                            }

                            const actionsCell = row.querySelector('.actions-cell');
                            if (actionsCell && data.actions_html) {
                                actionsCell.innerHTML = data.actions_html;
                                // Need to re-bind event listeners for newly added dropdown items
                                bindActions(actionsCell);
                            }
                        }
                    }
                })
                .catch(err => console.error('Error polling status:', err));
        });
    }

    setInterval(checkStatus, pollInterval);

    function bindActions(container) {
        container.querySelectorAll('.cancel-transcript').forEach(link => {
            if (link.dataset.bound) return;
            link.dataset.bound = "true";
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const trackId = this.dataset.trackId;
                if (confirm('Are you sure you want to cancel the transcription?')) {
                    fetch(`/track/${trackId}/transcript/cancel/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrfToken
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                            if (row) {
                                const statusCell = row.querySelector('.status-cell');
                                if (statusCell && data.html) {
                                    statusCell.innerHTML = data.html;
                                }
                                // Actions cell will be updated by poll eventually, or we can update it now
                                if (data.actions_html) {
                                    const actionsCell = row.querySelector('.actions-cell');
                                    actionsCell.innerHTML = data.actions_html;
                                    bindActions(actionsCell);
                                }
                            }
                            showToast('Transcription cancelled.', 'success');
                        } else {
                            showToast(data.message || 'Unable to cancel transcription.', 'error');
                        }
                    })
                    .catch(() => showToast('Unable to cancel transcription.', 'error'));
                }
            });
        });

        container.querySelectorAll('.retry-transcript').forEach(link => {
            if (link.dataset.bound) return;
            link.dataset.bound = "true";
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const trackId = this.dataset.trackId;
                const formData = new FormData();
                formData.append('action', 'request');

                fetch(`/track/${trackId}/transcript/`, {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrfToken },
                    body: formData
                })
                .then(response => {
                    if (!response.ok) throw new Error();
                    return fetch(`/api/transcript/status/${trackId}/?show_edit_track=true`);
                })
                .then(r => r.json())
                .then(data => {
                    const row = document.querySelector(`tr[data-track-id="${trackId}"]`);
                    if (row && data.html) {
                        const statusCell = row.querySelector('.status-cell');
                        if (statusCell) {
                            statusCell.innerHTML = data.html;
                        }
                        if (data.actions_html) {
                            const actionsCell = row.querySelector('.actions-cell');
                            actionsCell.innerHTML = data.actions_html;
                            bindActions(actionsCell);
                        }
                    }
                    showToast('Transcription retry requested.', 'success');
                })
                .catch(() => showToast('Unable to retry transcription.', 'error'));
            });
        });
    }

    bindActions(document);
});
</script>
{% endblock %}
